/*
package org.specs2.guide.linalg.linearindependence

import com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace
import org.specs2.execute.Success
import scala.collection.immutable.{Vector => _}
import org.specs2.ugbase.UserGuidePage



object Basis_UserGuidePage extends UserGuidePage {

     def is = "Basis".title ^
          s2"""



<a href='https://i.imgsafe.org/b9593080da.png' target='_blank'><img src='https://i.imgsafe.org/b9593080da.png' border='0'/></a>

To understand the concept of a basis, we first need to learn the concept of span and spanning sets.


## DEFINITION: Span
<a href='https://i.imgsafe.org/b9593cb8e9.png' target='_blank'><img src='https://i.imgsafe.org/b9593cb8e9.png' border='0'/></a>

You may have noticed that we refer to exactly n vectors that span an n-dimensional space. We will see the rule behind
 this in Propositions 2.27, 2.28, and 2.31.

## Example 1
<a href='https://i.imgsafe.org/b98561c7fe.png' target='_blank'><img src='https://i.imgsafe.org/b98561c7fe.png' border='0'/></a>
<a href='https://i.imgsafe.org/b985714c46.png' target='_blank'><img src='https://i.imgsafe.org/b985714c46.png' border='0'/></a>
<a href='https://i.imgsafe.org/b9857cf4ad.png' target='_blank'><img src='https://i.imgsafe.org/b9857cf4ad.png' border='0'/></a>
<a href='https://i.imgsafe.org/b98588e81f.png' target='_blank'><img src='https://i.imgsafe.org/b98588e81f.png' border='0'/></a>

Now we see how this plays out in code:

##### Code
     ${snippet{
          import com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ColumnBindMatrix
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace
          import org.apache.commons.lang3.math.Fraction

          import org.linalg.studies.Ext._

          val v1 = new DenseVector(1.0, 2.0)
          val v2 = new DenseVector(-1.0, 1.0)
          val vectors = new ColumnBindMatrix(v1, v2)

          // TODO check if "inSpan" means same as "isLinIndependent" then add this paragraph in talk below this code.
          //MOST GENERAL: checking that the vectors span the R^2 space: checking that rref = identity is one
          // condition and checking that rowNum = colNum = dim(R^2) = 2 is the other condition
          vectors.span(2) shouldEqual false
          vectors.reducedEchelon.equalTo(vectors.ONE()) shouldEqual false

          // TODO is this correct way of saying it: whether <3,2> is in span of v1 and v2?
          //LESS GENERAL: checking that the vector <3,2> is in the span of v1 and v2 (whether there exists a linear
          // combination of the vectorSet that equals the vector.)
          val singleVec = new DenseVector(3.0, 2.0)
          val realVecSpace = new RealVectorSpace(vectors)
          realVecSpace.isSpanned(singleVec) shouldEqual true

          // LEAST GENERAL: taking a vector to convert it so that the given vector will be spanned/generated by v1 and v2.
          // NOTE: these are the coefficients used to make linear combo of v1,v2 so <3,2> is spanned by v1,v2
          singleVec.convertToBeSpannedBy(vectors) shouldEqual Array(Fraction.getFraction(5,3), Fraction.getFraction(-4,3))

          // 8<--
          Success("Row reduced echelon form: " + vectors.reducedEchelon.show() + "\n\n" +
          "Coefficients after solving the system: " + singleVec.convertToBeSpannedBy(vectors).show)
          // 8<--

     }.offsetIs(-10)}

Whether the vectors in `vectorSet` span a space is the same as whether the row reduced echelon form of that matrix
equals the identity matrix, `vectorSet.ONE()`. If so, then the arbitrary vector `<a, b>` in the R^2 space can be
produced by a linear combination of the column vectors of the `vectorSet` matrix. If a linear combination can be
produced, that means the scalars of the system are zero and each column has a leading "1".

In the above, the function `convertToBeInSpanOf()` correctly gives the coefficients 5/3 and -4/3. To get our original
vector <3, 2> we have to form a linear combination of the coefficients and the vectors `v1` and `v2`. To illustrate:
`(5/3)v1 + (-4/3)v2 = (5/3)<1,2> - (4/3)<-1,1> = <5/3, 10/3> + <4/3, -4/3> = <3, 2>`


## Example 2
<a href='https://i.imgsafe.org/b95944b685.png' target='_blank'><img src='https://i.imgsafe.org/b95944b685.png' border='0'/></a>

##### Code

     ${snippet{
          import com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ColumnBindMatrix
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace
          import org.apache.commons.lang3.math.Fraction

          import org.linalg.studies.Ext._

          val v1 = new DenseVector(1.0, -2.0)
          val v2 = new DenseVector(0.0, 0.0)
          val vectors = new ColumnBindMatrix(v1, v2)

          // TODO check if "inSpan" means same as "isLinIndependent" then add this paragraph in talk below this code.
          //MOST GENERAL: checking that the vectors span the R^2 space: checking that rref = identity is one
          // condition and checking that rowNum = colNum = dim(R^2) = 2 is the other condition
          vectors.span(2) shouldEqual false
          vectors.reducedEchelon.equalTo(vectors.ONE()) shouldEqual false

          // TODO is this correct way of saying it: whether <3,2> is in span of v1 and v2?
          //LESS GENERAL: checking that the vector <3,2> is in the span of v1 and v2 (whether there exists a linear
          // combination of the vectorSet that equals the vector.)
          // NOTE <3,2> is not spanned by v1 and v2 because v1 and v2 do not span R2 and so cannot span a vector from
          // R2.
          val singleVec = new DenseVector(3.0, 2.0)
          val realVecSpace = new RealVectorSpace(vectors)
          realVecSpace.isSpanned(singleVec) shouldEqual false

          // LEAST GENERAL: taking a vector to convert it so that the given vector will be spanned/generated by v1 and v2.
          // NOTE: these are the coefficients used to make linear combo of v1,v2 so <3,2> is spanned by v1,v2
          // NOTE there are no coefficients because v1 and v2 do not span R2
          singleVec.convertToBeSpannedBy(vectors) shouldEqual Array()

          // 8<--
          Success("Row reduced echelon form: " + vectors.reducedEchelon.show() + "\n\n" +
               "Coefficients after solving the system: " + singleVec.convertToBeSpannedBy(vectors).show)
          // 8<--
     }.offsetIs(-10)}

Unlike the previous example, here the `vectorSet` does not span the real space R2 because the scalar coefficients
from solving the system are not zero. See - the row reduced echelon form does not have leading "1"s in each column.
Thus, the vectors `v1` and `v2` do not span R^2 so no other vector from R2 such as <3,2> can be spanned by `v1` and
`v2`. This is why we have no coefficients to convert the vector <3, 2> to be spanned by `v1` and `v2`.


## Example 3

Here is another example - we have to check to see if the 3 given vectors below span the R^3 vector space.

<a href='https://i.imgsafe.org/d1cfabb82d.png' target='_blank'><img src='https://i.imgsafe.org/d1cfabb82d.png' border='0'/></a>

##### Code

     ${snippet{
          import com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ColumnBindMatrix
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace
          import org.apache.commons.lang3.math.Fraction

          import org.linalg.studies.Ext._

          val v1 = new DenseVector(1, 2, 1)
          val v2 = new DenseVector(2, 4, 0)
          val v3 = new DenseVector(-2, -2, 3)
          val vectors = new ColumnBindMatrix(v1, v2, v3)

          //MOST GENERAL: checking that the vectors span the R^2 space: checking that rref = identity is one
          // condition and checking that rowNum = colNum = dim(R^2) = 2 is the other condition
          vectors.span(3) shouldEqual true
          vectors.reducedEchelon.equalTo(vectors.ONE()) shouldEqual true

          //LESS GENERAL: checking that an example vector <4, 7, 8> is in the span of v1,v2,v3 (whether there exists a
          // linear combination of the vectorSet that equals the vector).
          val singleVec = new DenseVector(4, 7, 8)
          val realVecSpace = new RealVectorSpace(vectors)
          realVecSpace.isSpanned(singleVec) shouldEqual true

          // LEAST GENERAL: taking a vector to convert it so that the given vector will be spanned/generated by v1 and v2.
          // NOTE: these are the coefficients used to make linear combo of v1,v2,v3 so that <4,7,8> is spanned by them.
          singleVec.convertToBeSpannedBy(vectors) shouldEqual Array(Fraction.getFraction("19/2"), Fraction
               .getFraction("-13/4"), Fraction.getFraction("-1/2"))

          // 8<--
          Success("Row reduced echelon form: " + vectors.reducedEchelon.show() + "\n\n" +
               "Coefficients after solving the system: " + singleVec.convertToBeSpannedBy(vectors).show)
          // 8<--
     }.offsetIs(-10)}

We see that the vectors `v1`, `v2`, and `v3` span or generate the vector space R^3. This allows us to take an
arbitrary vector `<4,7,8>` in R^3 and discover the coefficients required to make a linear combination of `v1`,
`v2`, and `v3` that will make `<4,7,8>` be spanned/generated by these vectors. To illustrate: `(19/2)v1 - (13/4)v2 -
(1/2)v3 = (19/2)<1,2,1> - (13/4)<2,4,0> - (1/2)<-2,-2,3> = <19/2, 19, 19/2> - <13/2, 13, 0> + <1, 1, -3/2> = <4, 7, 8>`


## Example 4

Here is another example - we must check if the following vectors span R^3. This time we will see that they don't.

<a href='https://i.imgsafe.org/e0ccdc6928.png' target='_blank'><img src='https://i.imgsafe.org/e0ccdc6928.png' border='0'/></a>

##### Code
     ${snippet{
          import com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ColumnBindMatrix
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace

          import org.linalg.studies.Ext._

           val v1 = new DenseVector(1, 1, 1)
           val v2 = new DenseVector(2, 2, 2)
           val v3 = new DenseVector(1, 2, 3)
           val vectors = new ColumnBindMatrix(v1, v2, v3)

           //MOST GENERAL: checking that the vectors span the R^2 space: checking that rref = identity is one
           // condition and checking that rowNum = colNum = dim(R^2) = 2 is the other condition
           vectors.span(3) shouldEqual false
           vectors.reducedEchelon.equalTo(vectors.ONE()) shouldEqual false

           //LESS GENERAL: checking that an example vector <4, 7, 8> is in the span of v1,v2,v3 (whether there exists a
           // linear combination of the vectorSet that equals the vector).
          val singleVec = new DenseVector(4,7,8)
           val realVecSpace = new RealVectorSpace(vectors)
           realVecSpace.isSpanned(singleVec) shouldEqual false

           // LEAST GENERAL: taking a vector to convert it so that the given vector will be spanned/generated by v1 and v2.
           // NOTE: these are the coefficients used to make linear combo of v1,v2,v3 so that <4,7,8> is spanned by them.
          singleVec.convertToBeSpannedBy(vectors) shouldEqual Array()

           // 8<--
           Success("Row reduced echelon form: " + vectors.reducedEchelon.show() + "\n\n" +
                "Coefficients after solving the system: " + singleVec.convertToBeSpannedBy(vectors).show)
           // 8<--

     }.offsetIs(-10)}

## Example 5

Here is a last example.

<a href='https://i.imgsafe.org/e0fe7d81a3.png' target='_blank'><img src='https://i.imgsafe.org/e0fe7d81a3.png' border='0'/></a>

The augmented matrices look like:

<a href='https://i.imgsafe.org/e14b4b4781.png' target='_blank'><img src='https://i.imgsafe.org/e14b4b4781.png' border='0'/></a>

and we are essentially just solving the systems for the coefficients. The result for a) is below but there is no
solution for b) because the vectors are linearly dependent.
<a href='https://i.imgsafe.org/e14f93a9d3.png' target='_blank'><img src='https://i.imgsafe.org/e14f93a9d3.png' border='0'/></a>


##### Code
     ${snippet{
          import com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ColumnBindMatrix
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace

          import org.apache.commons.lang3.math.Fraction

          import org.linalg.studies.Ext._

          // part a)
          val v1 = new DenseVector(1, 2, 3)
          val v2 = new DenseVector(1, 5, 4)
          val v3 = new DenseVector(0, 0, 9)
          val vSet = new ColumnBindMatrix(v1, v2, v3)


          /**
          todo make it have all these elements at the same time:
          todo Console.println(vset)
          todo Console.println(vset.reducedRowEchelon())
          todo Console.println(vset.linearlyIndependent())
          todo Console.println(vset.spans(vset))
          todo Console.println(vset.isSpanned(v))
          todo Console.println(vset.getSpanningCoefficients(v))
          */


          // part b)
          val u1 = new DenseVector(1, 4, 7)
          val u2 = new DenseVector(2, 5, 8)
          val u3 = new DenseVector(3, 6, 9)
          val uSet = new ColumnBindMatrix(u1, u2, u3)

          //MOST GENERAL: checking that the vectors span the R^2 space
          vSet.span(3) shouldEqual true
          vSet.reducedEchelon.equalTo(vSet.ONE()) shouldEqual true
          uSet.span(3) shouldEqual false
          uSet.reducedEchelon.equalTo(uSet.ONE()) shouldEqual false

          //LESS GENERAL: checking that an the given vector <1, 3, 4> is in the span of v1,v2,v3
          val singleVec = new DenseVector(1,3,4)
          new RealVectorSpace(vSet).isSpanned(singleVec) shouldEqual true
          new RealVectorSpace(uSet).isSpanned(singleVec) shouldEqual false

          // LEAST GENERAL: converting <1,3,4> so it will be spanned/generated by the respective vectors.
          singleVec.convertToBeSpannedBy(vSet) shouldEqual Array(Fraction.getFraction("2/3"),
               Fraction.getFraction("1/3"), Fraction.getFraction("2/27"))
          singleVec.convertToBeSpannedBy(uSet) shouldEqual Array()

          // 8<--
          Success("Row reduced echelon for vSet: " + vSet.reducedEchelon.show() + "\n\n" +
               "Coefficients after solving vSet: " + singleVec.convertToBeSpannedBy(vSet).show + "\n\n" +
               "Row reduced echelon for uSet: " + uSet.reducedEchelon.show() + "\n\n" +
               "Coefficients after solving uSet: " + singleVec.convertToBeSpannedBy(uSet).show)
          // 8<--

     }.offsetIs(-10)}


## DEFINITION: Basis

Now that we've covered span, we have the tools to understand what a basis is.
Basis vectors stem from the motivation of having a simple way to represent the vectors. How can we do this? Given
some vectors we can generate others by a linear combination. We need JUST enough vectors to build all other vectors
from them through linear combination. This set of just enough vectors is called a basis.
An example is the standard unit vectors `e1 = <1, 0>` and `e2 = <0, 1>` for R^2. This set of vectors is the basis which
forms the x and y axes of R^2 because `e1 = <1, 0>` specifies x direction and `e2 = <0, 1>` specifies the y direction.
Each additional basis vector introduces a new direction.

You can think of a basis as the axes the coordinate system that describes the vector space. This means that every
vector in a vector space V can be written in terms of the coordinate system which is represented by the basis vectors.
You can decompose each vector into its basis vectors.


<a href='https://i.imgsafe.org/e0764e1351.png' target='_blank'><img src='https://i.imgsafe.org/e0764e1351.png' border='0'/></a>

## Example 1

<a href='https://i.imgsafe.org/e0923a14f6.png' target='_blank'><img src='https://i.imgsafe.org/e0923a14f6.png' border='0'/></a>

##### Code
     ${snippet{
          import com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ColumnBindMatrix
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace
          import org.apache.commons.lang3.math.Fraction

          import org.linalg.studies.Ext._

          val v1 = new DenseVector(1.0, 1.0)
          val v2 = new DenseVector(1.0, -1.0)
          val vectors = new ColumnBindMatrix(v1, v2)

          // the vectors are a basis for R^2 if and only if <=> they span R^2 and are linearly independent
          vectors.span(2) shouldEqual true
          vectors.linearlyIndependent shouldEqual true
          // overall check
          vectors.basis(2) shouldEqual true


          // 8<--
          Success("Row reduced echelon form: " + vectors.reducedEchelon.show() + "\n\n" +
               "Do the vectors span R^2? " + vectors.span(2) + "\n" +
               "Vectors are linearly independent? " + vectors.linearlyIndependent + "\n" +
               "Vectors are a basis for R^2? " + vectors.basis(2))
          // 8<--
     }.offsetIs(-10)}


The standard unit vectors `e1` and `e2` are another basis for R^2. In fact, they are called the natural or standard
basis for R^2. In other words, they form a coordinate system for R^2. This means that every vector in R^2 can be
written in terms of these vectors. For example:

<a href='https://i.imgsafe.org/e631dcafee.png' target='_blank'><img src='https://i.imgsafe.org/e631dcafee.png' border='0'/></a>

Using non-standard basis vectors is beneficial, though. For example, a vector in a different bassis or coordinate
system may have a structure related to that basis which is hidden in the standard representation. It may be a
relevant and useful structure.
For example, looking at a force applied to an object on an inclined plane, the components paralle and perpendicular
to the plane are far more useful than the horizontal and vertical components. Choosing a basis wisely can greatly
reduce the amount of arithmetic we have to do.

<a href='https://i.imgsafe.org/e62507454b.png' target='_blank'><img src='https://i.imgsafe.org/e62507454b.png' border='0'/></a>

NOTE: there is not just one basis for a vector space. As long as the vectors form a square system and has the same
number of rows and columns as the dimension of the vector space AND are linearly independent and span the vector
space, then they are considered a basis for that vector space. As we will see in in Proposition 2.27 though, only one
 of these conditions is required - span or linear independence.


## Propositions and examples

### PROPOSITION 2.27

<a href='https://i.imgsafe.org/e64c9a4ca3.png' target='_blank'><img src='https://i.imgsafe.org/e64c9a4ca3.png' border='0'/></a>


Similarly, Proposition 2.28 says we only need to prove the n vectors span R^n in order for them to be a basis for R^n
. So now we don't need both conditions, we need only one to provide they are a basis for R^n.
     ${snippet {
          //TODO: if either span or linear independence is false (one example of each) then is still basis or NOT
     }}




### PROPOSITION 2.28

<a href='https://i.imgsafe.org/e7eb4bb49e.png' target='_blank'><img src='https://i.imgsafe.org/e7eb4bb49e.png' border='0'/></a>


## Example 1

As we see below, by Proposition 2.27, we only need to prove linear independence for the 3 by 3 vectors for them to be
 a basis for R^3.

<a href='https://i.imgsafe.org/e78ea4bedb.png' target='_blank'><img src='https://i.imgsafe.org/e78ea4bedb.png' border='0'/></a>

##### Code
     ${snippet{
          import com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ColumnBindMatrix
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector

          import org.linalg.studies.Ext._

          val v1 = new DenseVector(1, 0, 1)
          val v2 = new DenseVector(0, 1, -1)
          val v3 = new DenseVector(-2, 3, 0)
          val vectors = new ColumnBindMatrix(v1, v2, v3)

          // TODO is it possible for either span or lin independence to be false? If either is false then does that
          // TODO make vectors not a basis for R^2 (exclusive or)?
          vectors.span(3) shouldEqual true
          vectors.linearlyIndependent shouldEqual true
          // overall check
          vectors.basis(3) shouldEqual true

          // 8<--
          Success("Row reduced echelon form: " + vectors.reducedEchelon.show() + "\n\n" +
               "Do the vectors span R^3? " + vectors.span(3) + "\n" +
               "Vectors are linearly independent? " + vectors.linearlyIndependent + "\n" +
               "Vectors are a basis for R^3? " + vectors.basis(3))
          // 8<--
     }.offsetIs(-10)}


## Example 2

<a href='https://i.imgsafe.org/e8843b20fd.png' target='_blank'><img src='https://i.imgsafe.org/e8843b20fd.png' border='0'/></a>

We only need to show that either the span or linear independence condition fails, according to Propositions 2.27 and 2
.28.

##### Code
     ${snippet{

          //TODO: if either span or linear independence is false (one example of each) then is still basis or NOT?
          // is it possible that one is true and other is false? Here is the example where both are false.

          import com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ColumnBindMatrix
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector

          import org.linalg.studies.Ext._

          val v1 = new DenseVector(1, 1, 2)
          val v2 = new DenseVector(-1, 1, -2)
          val v3 = new DenseVector(1, -5, 2)
          val vectors = new ColumnBindMatrix(v1, v2, v3)

          // TODO is it possible for either span or lin independence to be false? If either is false then does that
          // TODO make vectors not a basis for R^2 (exclusive or)?
          vectors.span(3) shouldEqual false
          vectors.linearlyIndependent shouldEqual false
          // overall check
          vectors.basis(3) shouldEqual false

          // 8<--
          Success("Row reduced echelon form: " + vectors.reducedEchelon.show() + "\n\n" +
               "Do the vectors span R^3? " + vectors.span(3) + "\n" +
               "Vectors are linearly independent? " + vectors.linearlyIndependent + "\n" +
               "Vectors are a basis for R^3? " + vectors.basis(3))
          // 8<--

     }.offsetIs(-10)}



### PROPOSITION 2.29

<a href='https://i.imgsafe.org/e7eb5a0f9a.png' target='_blank'><img src='https://i.imgsafe.org/e7eb5a0f9a.png' border='0'/></a>

This means there is no other solution to the linear system of Ax = b where A = basis vectors and b = vector you are
trying to write in terms of the basis vectors.

## Example

##### Code
     ${snippet{
          import com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ColumnBindMatrix
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector
          import org.apache.commons.lang3.math.Fraction

          import org.linalg.studies.Ext._

          val v1 = new DenseVector(9, 4, -2)
          val v2 = new DenseVector(-1, 1, -2)
          val v3 = new DenseVector(3, 3, 1)
          val vectors = new ColumnBindMatrix(v1, v2, v3)

          vectors.span(3) shouldEqual true
          vectors.linearlyIndependent shouldEqual true
          // overall check
          vectors.basis(3) shouldEqual true

          // We cannot prove it through code but this is the only unique solution to the linear combination
          // of the basis vectors and arbitrarily chosen vector <3,4,5>
          val b = new DenseVector(3,4,5)
          b.convertToBeSpannedBy(vectors) shouldEqual Array(Fraction.getFraction("-29/55"),
               Fraction.getFraction("-9/11"), Fraction.getFraction("127/55"))

          // 8<--
          Success("Row reduced echelon form: " + vectors.reducedEchelon.show() + "\n\n" +
               "Do the vectors span R^3? " + vectors.span(3) + "\n" +
               "Vectors are linearly independent? " + vectors.linearlyIndependent + "\n" +
               "Vectors are a basis for R^3? " + vectors.basis(3) + "\n\n" +
               "Unique coefficients that form linear combination of basis and <3,4,5>: " +
                    b.convertToBeSpannedBy(vectors).show)
          // 8<--

     }.offsetIs(-10)}




## LEMMA 2.30

<a href='https://i.imgsafe.org/e8d80dcf73.png' target='_blank'><img src='https://i.imgsafe.org/e8d80dcf73.png' border='0'/></a>

This means if you want linearly independent vectors in R^n, then you've got to have no more than n. So you can have
2,3,4,5,6 or 7 linearly independent vectors in R^7 but never 8 or more.
Of course, you can also have linearly dependent vectors even though there are no more than n vectors in the R^n space.


## Example

##### Code
     ${snippet{
          import com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ColumnBindMatrix
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector

          import org.linalg.studies.Ext._

          val v1 = new DenseVector(1, 2, -1, 9)
          val v2 = new DenseVector(3, 2, 8, 0)
          val v3 = new DenseVector(1, 1, -1, 8)
          val v4 = new DenseVector(13, 11, 0, 5)
          val v5 = new DenseVector(4, 5, 1, 0)

          val twoIndepVecsInR4 = new ColumnBindMatrix(v1, v2)
          val threeIndepVecsInR4 = new ColumnBindMatrix(v1, v2, v3)
          val fourIndepVecsInR4 = new ColumnBindMatrix(v1, v2, v3, v4)
          val fiveDepVecsInR4 = new ColumnBindMatrix(v1, v2, v3, v4, v5)

          twoIndepVecsInR4.linearlyIndependent shouldEqual true
          threeIndepVecsInR4.linearlyIndependent shouldEqual true
          fourIndepVecsInR4.linearlyIndependent shouldEqual true
          fiveDepVecsInR4.linearlyIndependent shouldEqual false

          // Of course, you can also have linearly dependent vectors even though there are no more than n vectors in
          // the R^n space.
          val u1 = new DenseVector(1, 2, -1, 9)
          val u2 = new DenseVector(-1, -2, 1, -9)
          val u3 = new DenseVector(1, 1, -1, 8)
          val u4 = new DenseVector(13, 11, 0, 5)
          val u5 = new DenseVector(4, 5, 1, 0)

          val twoDepVecsInR4 = new ColumnBindMatrix(u1, u2)
          val threeDepVecsInR4 = new ColumnBindMatrix(u1, u2, u3)
          val fourDepVecsInR4 = new ColumnBindMatrix(u1, u2, u3, u4)
          val fiveDepVecsInR4Again = new ColumnBindMatrix(u1, u2, u3, u4, u5)

          twoDepVecsInR4.linearlyIndependent shouldEqual false
          threeDepVecsInR4.linearlyIndependent shouldEqual false
          fourDepVecsInR4.linearlyIndependent shouldEqual false
          fiveDepVecsInR4Again.linearlyIndependent shouldEqual false

          // 8<--
          Success("Two independent?: " + twoIndepVecsInR4.linearlyIndependent + twoIndepVecsInR4.show() + "\n\n" +
               "Three independent?: " + threeIndepVecsInR4.linearlyIndependent + threeIndepVecsInR4.show() + "\n\n" +
               "Four independent?: " + fourIndepVecsInR4.linearlyIndependent + fourIndepVecsInR4.show() + "\n\n" +
               "Five dependent?: " + fiveDepVecsInR4.linearlyIndependent + fiveDepVecsInR4.show() + "\n\n" +
               "Two dependent?: " + twoDepVecsInR4.linearlyIndependent + twoDepVecsInR4.show() + "\n\n" +
               "Three dependent?: " + threeDepVecsInR4.linearlyIndependent + threeDepVecsInR4.show() + "\n\n" +
               "Four dependent?: " + fourDepVecsInR4.linearlyIndependent + fourDepVecsInR4.show() + "\n\n" +
               "Five dependent?: " + fiveDepVecsInR4Again.linearlyIndependent + fiveDepVecsInR4Again.show())
          // 8<--

     }.offsetIs(-10)}




## PROPOSITION 2.31

<a href='https://i.imgsafe.org/f5bd7e5292.png' target='_blank'><img src='https://i.imgsafe.org/f5bd7e5292.png' border='0'/></a>
<a href='https://i.imgsafe.org/f5bd88a69c.png' target='_blank'><img src='https://i.imgsafe.org/f5bd88a69c.png' border='0'/></a>

This means that every basis of R^n has exactly n vectors with n elements. It goes the other way too - any nxn system
is a basis for R^n. Proposition 2.27 states the relation: n independent in R^n => basis for R^n and Proposition
2.31 is the one that gives the backward relation: basis for R^n => n in R^n.
As we see in the code below, there are either too few vectors or too many for them to be a basis of R^3 even though
they are linearly independent.

##### Code
     ${snippet{
          import com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ColumnBindMatrix
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector

          import org.linalg.studies.Ext._

          val v1 = new DenseVector(1, 2, -1, 9)
          val v2 = new DenseVector(3, 2, 8, 0)
          val v3 = new DenseVector(1, 1, -1, 8)
          val v4 = new DenseVector(13, 11, 0, 5)
          val vectorSet = new ColumnBindMatrix(v1, v2, v3, v4)

          vectorSet.span(4) shouldEqual true
          vectorSet.linearlyIndependent shouldEqual true

          vectorSet.basis(2) shouldEqual false
          vectorSet.basis(3) shouldEqual true
          vectorSet.basis(4) shouldEqual false
          vectorSet.basis(5) shouldEqual false
          vectorSet.basis(6) shouldEqual false
          // etc...

          // we confirm that vectorSet is only a basis for R^3
          vectorSet.basisDim shouldEqual 4
          //note todo is this mistake? shouldn't it be R^4 not R^3???

          // 8<--
          Success("Vector set: " + vectorSet.show() + "\n\n" +
               "Spans R^4?: " + vectorSet.span(4) + "\n" +
               "Linear independence?: " + vectorSet.linearlyIndependent + "\n" +
               "It is a basis for R^" + vectorSet.basisDim.get + ".\n" +
               "Basis for R^2?: " + vectorSet.basis(2) + "\n" +
               "Basis for R^3?: " + vectorSet.basis(3) + "\n" +
               "Basis for R^4?: " + vectorSet.basis(4) + "\n" +
               "Basis for R^5?: " + vectorSet.basis(5) + "\n" +
               "Basis for R^6?: " + vectorSet.basis(6))
          // 8<--

     }.offsetIs(-10)}



## PROPOSITION 2.32

<a href='https://i.imgsafe.org/f5ab70e670.png' target='_blank'><img src='https://i.imgsafe.org/f5ab70e670.png' border='0'/></a>


## Example

<a href='https://i.imgsafe.org/106d359705.png' target='_blank'><img src='https://i.imgsafe.org/106d359705.png' border='0'/></a>


##### Code
     ${snippet{
          import com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ColumnBindMatrix
          import com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector
          import org.apache.commons.lang3.math.Fraction

          import org.linalg.studies.Ext._

          val v1 = new DenseVector(1, 0, 1)
          val v2 = new DenseVector(-1, 4, 1)
          val v3 = new DenseVector(2, 1, -2)
          val vectors = new ColumnBindMatrix(v1, v2, v3)



          // part a)
          vectors.span(3) shouldEqual true
          vectors.linearlyIndependent shouldEqual true

          v1.isOrthogonalTo(v2) shouldEqual true
          v1.isOrthogonalTo(v3) shouldEqual true
          v2.isOrthogonalTo(v3) shouldEqual true
          vectors.isOrthogonalSet shouldEqual true



          // part b)
          // we confirm that vectorSet is a basis (for R^3) because vectors are orthogonal
          vectors.basis(3) shouldEqual true
          vectors.basisDim shouldEqual 3

          // now converting the vector x to be in span of v1, v2, v3.
          val x = new DenseVector(8, -4, 3)
          val realVecSpace = new RealVectorSpace(vectors)

          realVecSpace.isSpanned(x) shouldEqual true
          x.convertToBeSpannedBy(vectors) shouldEqual Array("11/2".toFrac, "-7/6".toFrac, "2/3".toFrac)


          // 8<--
          Success("Vector set: " + vectors.show() + "\n\n" +
               "Do vectors span R^3?: " + vectors.span(3) + "\n" +
               "Are vectors linearly independent?: " + vectors.linearlyIndependent + "\n" +
               "Are vectors orthogonal?: " + vectors.isOrthogonalSet + "\n" +
               "Vectors are a basis for R^" + vectors.basisDim.get + "\n" +
               "Coefficients to put x in terms (linear combination) of v1,v2,v3: " +
                    x.convertToBeSpannedBy(vectors).show)
          // 8<--
     }.offsetIs(-10)}

Notice that here if the vectors are orthogonal and there are n vectors with n elements each, then they are a basis
for their vector space of dimension 3. Here we have a 3x3 system that is an orthogonal set so it is a basis for R^3.
For part b), we see that the coefficients that make `x` be spanned/generated by `v1`, `v2`, and `v3` are 11/2, -7/6,
 and 2/3.






So far we have talked about the concepts of basis and span in the real vector space, R^n, but not in the general
vector space. The definitions for basis and span in the general vector space are:


 // TODO
* matrices for general polynomial space (using suanshu polynomials)
* example of matrix bases.
* do polynomial linear independence function (implicit class for poly), example page 220 pdf solve that with code.
     """
}
*/
